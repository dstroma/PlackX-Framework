#!perl
use v5.36;
use Test::More;

do_tests();
done_testing();

#######################################################################

sub do_tests {

  # Hello World app
  {
    my $app = do './examples/single-file-apps/hello-world.psgi';
    my ($test_env, $response);

    ok(
      $app,
      'app loaded true'
    );

    is(
      ref $app => 'CODE',
      'app loaded coderef'
    );

    $test_env = test_env();
    $response = $app->($test_env);

    ok(
      (ref $response eq 'ARRAY' and scalar @$response == 3),
      'app execution returns PSGI response arrayref'
    );
    is(
      $response->[0] => 200,
      'response status correct'
    );

    is_deeply(
      $response->[1] => ['Content-Type', 'text/html'],
      'response content-type correct'
    );

    is(
      $response->[2][0] => 'Hello World!',
      'response body is correct'
    );

    # Test different query strings
    $test_env = test_env();
    $test_env->{QUERY_STRING} = 'name=Larry%20Wall';
    $response = $app->($test_env);
    is(
      $response->[2][0] => 'Hello Larry Wall',
      'response body is correct, different query string'
    );

    foreach my $wrong_path (qw|hello-world helo word helllo helloo worlld wworld worldd|) {
      $test_env = test_env();
      $test_env->{PATH_INFO} = "/$wrong_path";
      $response = $app->($test_env);
      is(
        $response->[0] => 404,
        "404 issued for non-existant route $wrong_path"
      );
    }

    foreach my $right_path (qw|hello world|) {
      $test_env = test_env();
      $test_env->{PATH_INFO} = "/$right_path";
      $response = $app->($test_env);
      is(
        $response->[2][0] => "You said ~$right_path~",
        "response body is correct with route param $right_path"
      );
    }
  }

  # Form app
  {
    my $app = do './examples/single-file-apps/form-app.psgi';
    my ($test_env, $response);

    ok(
      $app,
      'app loaded true'
    );

    is(
      ref $app => 'CODE',
      'app loaded coderef'
    );

    $test_env = test_env();
    $response = $app->($test_env);

    ok(
      (ref $response eq 'ARRAY' and scalar @$response == 3),
      'app execution returns PSGI response arrayref'
    );
    is(
      $response->[0] => 200,
      'response status correct'
    );

    is_deeply(
      $response->[1] => ['Content-Type', 'text/html'],
      'response content-type correct'
    );

    my $body;
    $body = join '', $response->[2]->@*;
    ok(
      $body =~ m|<html>|,
      'body has html open tag - prefilter works'
    );
    ok(
      $body =~ m|</html>|,
      'body has html close tag - postfilter works'
    );
    ok(
      $body =~ m|--Generated by|,
      '"Generated by" - postfilter works'
    );
    ok(
      $body =~ m|Please.+to continue|,
      'body has correct content'
    );

    # Test /login
    $test_env = test_env();
    $test_env->{PATH_INFO} = '/login';
    $response = $app->($test_env);
    $body = join '', $response->[2]->@*;

    ok(
      $body =~ m|<form|,
      '/login page has form'
    );

    $test_env = test_env();
    $test_env->{PATH_INFO} = '/login/submit';
    $response = $app->($test_env);
    $body = join '', $response->[2]->@*;

    is(
      $response->[0] => 405,
      'GET a page only accessible by POST should give 405 error'
    );

    ok(
      $body =~ m|cannot login|,
      'Correct error message'
    );

    # Post request
    use Plack::Test;
    use HTTP::Request::Common;
    test_psgi $app, sub ($server) {
        my $res = $server->(POST "/login/submit", { username => "mary", password => "lamb" });
        ok(
          $res->content =~ m/Incorrect username/,
          'Login with wrong username'
        );
    };

    test_psgi $app, sub ($server) {
        my $res = $server->(POST "/login/submit", { username => "larry", password => "perl" });
        ok(
          $res->content =~ m/Welcome back/,
          'Login with correct username'
        );
    };

    # Flash set
    my $message = 'hello-' . int(rand() * 10_000);
    $test_env = test_env();
    $test_env->{PATH_INFO} = "/flash/set/$message";
    $response = $app->($test_env);

    my $cookie_name;
    my $cookie_value;
    while (my $header = shift $response->[1]->@*) {
      next unless $header =~ m/^set-cookie$/i;
      my $value = shift $response->[1]->@*;
      ok(
        $value =~ m|$message|,
        'Cookie is set'
      );
      ($cookie_name, $cookie_value) = $value =~ m|^(.+?)=(.+?);|;
      last;
    }

    # Flash read
    $test_env = test_env();
    $test_env->{PATH_INFO} = "/flash/view";
    $test_env->{HTTP_COOKIE} = "$cookie_name=$cookie_value";
    $response = $app->($test_env);
    $body = join '', $response->[2]->@*;
    ok(
      $body =~ m|$message|,
      'Flash value is retrieved from client'
    );

    # Flash should be unset
    ok(
      (grep { $_ =~ m|^$cookie_name=;| } $response->[1]->@*),
      'Cookie set to blank value on next request'
    );

    # Cleanup callback
    {
      # silence used only once warning
      my $xyz = $PXF::Example::FormApp::Routes::counter;
    }
    $test_env = test_env();
    $test_env->{PATH_INFO} = "/callback";
    $app->($test_env) for 1..3;
    is(
      $PXF::Example::FormApp::Routes::counter => 3,
      'Cleanup callback works'
    );

    # Test non-dsl route and global filter
    $test_env = test_env();
    $test_env->{PATH_INFO} = "/page/12/view";
    $response = $app->($test_env);
    $body = join '', $response->[2]->@*;
    ok(
      $body =~ m|viewing page 12|,
      'Non dsl route with route param'
    );
    ok(
      $body =~ m|Generated by PXF|,
      'Global filter applied outside of package'
    );
  }
}

###############################################################################
sub test_env {
  return {
    'psgi.version' => [1, 1],
    'psgi.errors' => *::STDERR,
    'psgi.multiprocess' => '',
    'psgi.multithread' => '',
    'psgi.nonblocking' => '',
    'psgi.run_once' => '',
    'psgi.streaming' => 0,
    'psgi.url_scheme' => 'http',
    'psgix.harakiri' => 1,
    'psgix.input.buffered' => 1,
    'QUERY_STRING' => '',
    'HTTP_ACCEPT' => 'text/html,text/plain',
    'REQUEST_METHOD' => 'GET',
    'HTTP_USER_AGENT' => 'Mock',
    'SCRIPT_NAME' => '',
    'HTTP_ACCEPT_LANGUAGE' => 'en-US,en;q=0.9',
    'SERVER_PROTOCOL' => 'HTTP/1.0',
    'HTTP_SEC_FETCH_SITE' => 'none',
    'PATH_INFO' => '/',
    'HTTP_DNT' => '1',
    'HTTP_CACHE_CONTROL' => 'max-age=0',
    'HTTP_ACCEPT_ENCODING' => 'gzip, deflate, br',
    'REMOTE_ADDR' => '127.0.0.1',
    'HTTP_HOST' => 'localhost:5000',
    'SERVER_NAME' => 0,
    'REMOTE_PORT' => 62037,
    'SERVER_PORT' => 5000,
    'REQUEST_URI' => '/'
  };
}
